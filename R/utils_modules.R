module_to_package <- function(
  module_id, label_name,
  script_path, packages = NULL,
  load = F, root_dir = NULL
){
  src = readLines(script_path)

  .this = new.env(parent = globalenv())
  .inner = new.env(parent = .this)
  .this$..packages = packages
  .this$..call_stack = list()


  # functions
  .this$require = .this$library = function(package, ...){
    pkg = as.character(substitute(package))
    if(!pkg %in% installed.packages()[,1] && is.character(package)){
      pkg = package
    }
    assertthat::assert_that(pkg %in% installed.packages()[,1], msg = sprintf('Package not exists. Please Install package: %s', pkg))
    .this$..packages = c(.this$package, pkg)
    do.call(base::`library`, args = list(
      package = pkg, character.only = T
    ))
  }

  .this$rave_prepare = .this$rave_ignore = function(...){}

  .this$source = function(file, ...){
    # try to locate file
    module_dir = dirname(script_path)
    fpath = file.path(module_dir, file)
    if(!file.exists(fpath)){
      fpath = file
    }
    assertthat::assert_that(file.exists(fpath), msg = sprintf('Source file does not exist: %s', file))
    .this$..call_stack = c(.this$..call_stack, rev(rlang::parse_quos(paste(readLines(fpath), collapse = '\n'), env = .this)))
  }

  # TODO modify
  .this$rave_inputs = .this$rave_outputs = .this$rave_updates = .this$rave_execute = function(...){}


  # parse source
  .this$..call_stack = rev(rlang::parse_quos(paste(src, collapse = '\n'), env = .this))


  while (length(.this$..call_stack)){
    n = length(.this$..call_stack)
    quo = .this$..call_stack[[n]]
    .this$..call_stack[[n]] = NULL

    expr = rlang::quo_squash(quo)
    rave::logger(n); print(expr)
    res = rave::eval_dirty(quo, env = .inner)
  }

  # to create a package for this, the best way is to write down all functions to scripts and cache all variables
  # to a RData file and load them via a function
  nms = names(as.list(.inner, all.names = T))
  .func = new.env()
  sapply(nms, function(key){
    val = .inner[[key]]
    if(is.function(val)){
      .func[[key]] = val
      rm(list = key, envir = .inner)
    }
    NULL
  })
  # create package
  create_package(module_id = module_id,
                 env = .func,
                 data = .inner,
                 dependencies = .this$..packages,
                 load = load,
                 root_dir = root_dir)
}



#' @import stringr
create_package <- function(module_id, env = new.env(), data = new.env(),
                           dependencies = NULL, load = T, attach = FALSE, root_dir = NULL) {

  pkgName = paste('RAVE', module_id)
  pkgName = str_replace_all(pkgName, '[\\W_]', '')

  if(is.null(root_dir)){
    root_dir = file.path(rave_options('module_root_dir'), 'tempdir')
  }
  dir.create(root_dir, showWarnings = F, recursive = T)
  pack_dir = file.path(root_dir, pkgName)
  inst_dir = file.path(pack_dir, 'inst')
  src_file = file.path(pack_dir, 'R', 'aaa.R')



  # save script to pack_dir
  if(file.exists(pack_dir)){
    unlink(pack_dir, recursive=TRUE, force = T)
  }

  dependencies = unique(c(dependencies, 'rave'))


  env$..dependencies = function(){}
  env$..rave_init_vars = function(){}
  body(env$..rave_init_vars) = rlang::quo_squash(rlang::quo({
    ..rdata_file = system.file('vars.RData', package = !!pkgName)
    ..env = new.env()
    base::load(file = ..rdata_file, envir = ..env)
    ..env
  }))
  body(env$..dependencies) = {dependencies}
  package.skeleton(name=pkgName, path = root_dir, environment = env, force = T)

  # cat(src, sep = '\n', file = src_file)
  # remove man folder
  unlink(file.path(pack_dir, 'man'), recursive = T, force = T)
  dir.create(inst_dir, showWarnings = F, recursive = T)

  # cache data
  if(is.environment(data) && length(as.list(data, all.names = T))){
    nm = names(as.list(data, all.names = T))
    save(list = nm, envir = data, file = file.path(inst_dir, 'vars.RData'))
  }


  disc = file.path(pack_dir, 'DESCRIPTION')
  nsp = file.path(pack_dir, 'NAMESPACE')
  tmp = c(
    '# Generated by roxygen2: do not edit by hand',
    readLines(disc),
    'Imports:',
    paste(
      sapply(dependencies, function(p){
        if(p %in% (installed.packages()[,1])){
          ver = utils::packageVersion(p)
          sprintf('\t%s (>= %s)', p, as.character(ver))
        }else{
          p
        }
      }),
      collapse = ',\n'
    )
  )
  writeLines(tmp, disc)
  tmp = c('# Generated by roxygen2: do not edit by hand', readLines(nsp))
  writeLines(tmp, nsp)


  # roxygen2::roxygenise(pack_dir, clean = T, roclets = c("collate", "namespace"))
  # devtools::build(pack_dir)
  pkg = devtools::install(pack_dir, reload = T, quick = T, local = T, dependencies = T, upgrade_dependencies = T,
                          keep_source = T, quiet = T)


  if(base::isNamespaceLoaded(pkgName)){
    tryCatch({
      detach(paste0('package:', pkgName), unload = T, character.only = T)
    }, error = function(e){})
    base::unloadNamespace(pkgName)
  }
  if(load){
    e = do.call('loadNamespace', args = list(package = pkgName))
    if(attach){
      do.call('library', args = list(
        package = pkgName,
        character.only = T
      ))
    }
  }else{
    e = TRUE
  }


  invisible(e)
}



# e = module_to_package(load = T)
# b = e$..rave_init_vars()
# ls(b)
