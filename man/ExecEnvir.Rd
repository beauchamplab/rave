% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class-ExecEnvir.R
\name{ExecEnvir}
\alias{ExecEnvir}
\title{Session-based Module Runtime Environment Class}
\description{
where all the module functions are executed. It's rarely created
manually, use \code{\link[rave]{get_module}} to create module, run with 
\code{start_app(m, test.mode=TRUE)}, and then inspect modules.
}
\examples{

\dontrun{

# Load module
module <- get_module('ravebuiltins', 'power_explorer')

# Create execute environmen
execenv <- module$get_or_new_exec_env()
execenv$info()

}

}
\author{
Zhengjia Wang
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{.__rave_context__.}}{context string for current instance, indicating
whether the module is running locally (public, but internally used)}

\item{\code{.__rave_package__.}}{current package name to run (public, 
but internally used)}

\item{\code{.__rave_module__.}}{module ID (public, but internally used)}

\item{\code{.__rave_module_instance__.}}{self instance (public, but internally
used)}

\item{\code{module_env}}{\code{\link[rave]{ModuleEnvir}} instance}

\item{\code{cache_env}}{cache environment to store key-value pairs locally}

\item{\code{parent_env}}{the parent/top environment of the module, usually 
global environment or some name-space if the module is implemented as 
an R package}

\item{\code{wrapper_env}}{stores all the utility functions. Some functions are 
overridden there such as \code{\link[shiny]{observe}}, 
\code{rave_checks}, or \code{eval_when_ready}. These functions behave 
differently inside or outside of shiny context, and with or without data 
loaded. The environment will be locked once the module is initialized. 
The parent environment is \code{parent_env}}

\item{\code{static_env}}{stores module static functions. These functions are 
evaluated under \code{parse_env} and then moved here. The environment
is locked after initialization. Its parent environment is 
\code{wrapper_env}}

\item{\code{param_env}}{stores parameters and most of the user inputs. It can 
also serve as a repository for global variables. Unlike the previous
environments, \code{param_env} is unlocked, but module creators do not 
have access to this environment directly. The parent environment is 
\code{static_env}}

\item{\code{runtime_env}}{where the main part of module is running. All shiny
\code{\link[shiny]{observe}} and \code{\link[shiny]{observeEvent}} are 
redirected to this environment by default (unless using 
\code{shiny::observe}). All functions in \code{static_env} have access 
to this environment. The parent environment is \code{param_env}}

\item{\code{async_env}}{where asynchronous codes run}

\item{\code{parse_env}}{environment where modules are parsed. The parent 
environment is \code{runtime_env}. Once all functions are evaluated, 
this environment is not used. However, module creators don't directly 
access this environment once the module is initialized.}

\item{\code{ns}}{shiny name-space functions, is equivalent to 
\code{shiny::NS(module_id)}. The goal is to add prefixes to module inputs
so that two modules with the same input ID are named differently}

\item{\code{auto_execute}}{(Deprecated) whether to auto-calculate results}

\item{\code{manual_inputIds}}{character vector; name list of manually input IDs.
Used when the algorithm takes long to run}

\item{\code{rendering_inputIds}}{character vector; name list of input IDs that 
when one of the corresponding inputs is changed, then \code{rave_execute}
will not get evaluated. Only the outputs are changed.}

\item{\code{input_update}}{expressions to update inputs}

\item{\code{register_output_events}}{expressions to register outputs}

\item{\code{register_input_events}}{expressions to register inputs}

\item{\code{execute}}{module main function. The function is dynamically 
generated. Don't call directly.}

\item{\code{async_module}}{(experimental) whether the module contains any 
asynchronous part}

\item{\code{global_reactives}}{shiny global \code{reactives}, internal use only}

\item{\code{local_reactives}}{shiny local \code{reactives}, internal use only}

\item{\code{internal_reactives}}{internal reactive values to control some 
elements, internal use only}

\item{\code{ready_functions}}{functions to run when the module is ready. The 
functions are called at the last step of \code{\link[rave]{shinirize}}. 
Usually it's used along with \code{eval_when_ready}, to make sure  
\code{global_reactives} and \code{local_reactives} getting registered
before functions calls}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{input_ids}}{vector of input IDs (read-only)}

\item{\code{input_labels}}{vector of input labels (read-only)}

\item{\code{output_labels}}{vector of output labels (read-only)}

\item{\code{output_ids}}{vector of output IDs (read-only)}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-reload}{\code{ExecEnvir$reload()}}
\item \href{#method-finalize}{\code{ExecEnvir$finalize()}}
\item \href{#method-info}{\code{ExecEnvir$info()}}
\item \href{#method-print}{\code{ExecEnvir$print()}}
\item \href{#method-clean}{\code{ExecEnvir$clean()}}
\item \href{#method-new}{\code{ExecEnvir$new()}}
\item \href{#method-reset}{\code{ExecEnvir$reset()}}
\item \href{#method-copy}{\code{ExecEnvir$copy()}}
\item \href{#method-execute_with}{\code{ExecEnvir$execute_with()}}
\item \href{#method-names}{\code{ExecEnvir$names()}}
\item \href{#method-register_module}{\code{ExecEnvir$register_module()}}
\item \href{#method-register_context}{\code{ExecEnvir$register_context()}}
\item \href{#method-rave_inputs}{\code{ExecEnvir$rave_inputs()}}
\item \href{#method-rave_outputs}{\code{ExecEnvir$rave_outputs()}}
\item \href{#method-rave_updates}{\code{ExecEnvir$rave_updates()}}
\item \href{#method-rave_execute}{\code{ExecEnvir$rave_execute()}}
\item \href{#method-set_browser}{\code{ExecEnvir$set_browser()}}
\item \href{#method-generate_input_ui}{\code{ExecEnvir$generate_input_ui()}}
\item \href{#method-generate_output_ui}{\code{ExecEnvir$generate_output_ui()}}
\item \href{#method-is_global}{\code{ExecEnvir$is_global()}}
\item \href{#method-clone}{\code{ExecEnvir$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reload"></a>}}
\if{latex}{\out{\hypertarget{method-reload}{}}}
\subsection{Method \code{reload()}}{
(experimental) signal the modules to reload
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$reload()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
none
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-finalize"></a>}}
\if{latex}{\out{\hypertarget{method-finalize}{}}}
\subsection{Method \code{finalize()}}{
garbage collection
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$finalize()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
none
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-info"></a>}}
\if{latex}{\out{\hypertarget{method-info}{}}}
\subsection{Method \code{info()}}{
print variables in different layers (environment)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$info()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
none
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
print the memory address
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$print(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{ignored}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
memory address
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clean"></a>}}
\if{latex}{\out{\hypertarget{method-clean}{}}}
\subsection{Method \code{clean()}}{
clean the environments to release the resource
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$clean()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
none
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
constructor
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$new(session = getDefaultReactiveDomain(), parent_env = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{session}}{shiny session instance}

\item{\code{parent_env}}{parent environment of this instance: package name space
or global environment}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reset"></a>}}
\if{latex}{\out{\hypertarget{method-reset}{}}}
\subsection{Method \code{reset()}}{
reset the runtime environment, rarely used
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$reset(inputs)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{inputs}}{reactive value list}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
none
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-copy"></a>}}
\if{latex}{\out{\hypertarget{method-copy}{}}}
\subsection{Method \code{copy()}}{
(deprecated) copy the instance locally
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$copy(
  session_id = "__fake_runtime_env__",
  data_env = getDefaultDataRepository()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{session_id}}{character}

\item{\code{data_env}}{where the data is stored, default is the environment 
returned by \code{\link[rave]{getDefaultDataRepository}}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a copied instance
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-execute_with"></a>}}
\if{latex}{\out{\hypertarget{method-execute_with}{}}}
\subsection{Method \code{execute_with()}}{
(deprecated) execute module with given parameter
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$execute_with(param, async = FALSE, plan = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{param}}{named list}

\item{\code{async}}{whether to run the whole module}

\item{\code{plan}}{future plan}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
runtime environment
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-names"></a>}}
\if{latex}{\out{\hypertarget{method-names}{}}}
\subsection{Method \code{names()}}{
returns names of a list, if names are null, 
returns blank characters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$names(x)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{a list}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the names of the list
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-register_module"></a>}}
\if{latex}{\out{\hypertarget{method-register_module}{}}}
\subsection{Method \code{register_module()}}{
register \code{\link[rave]{ModuleEnvir}} instance
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$register_module(module_env)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{module_env}}{\code{\link[rave]{ModuleEnvir}} instance. The modules
are shared across different sessions, but to run the module, we need 
to create runtime environment, which is \code{ExecEnvir}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
none
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-register_context"></a>}}
\if{latex}{\out{\hypertarget{method-register_context}{}}}
\subsection{Method \code{register_context()}}{
Register 'RAVE' context for current environment 
(internally used)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$register_context(context = c("rave_running", "rave_running_local"))}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{context}}{context string to indicate whether the module is running 
locally}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
None
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rave_inputs"></a>}}
\if{latex}{\out{\hypertarget{method-rave_inputs}{}}}
\subsection{Method \code{rave_inputs()}}{
parse input components
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$rave_inputs(
  ...,
  .input_panels = list(),
  .tabsets = list(),
  .env = NULL,
  .manual_inputs = NULL,
  .render_inputs = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{shiny input calls, such as \code{textInput('id', 'Name', ...)}}

\item{\code{.input_panels, .tabsets}}{together define the input layouts}

\item{\code{.env}}{ignored, debug only}

\item{\code{.manual_inputs}}{input IDs that won't cause module re-calculate
when inputs are updated}

\item{\code{.render_inputs}}{input IDs that only trigger render functions when
updated}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
none
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rave_outputs"></a>}}
\if{latex}{\out{\hypertarget{method-rave_outputs}{}}}
\subsection{Method \code{rave_outputs()}}{
parse output components
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$rave_outputs(
  ...,
  .output_tabsets = list(),
  .tabsets = list(),
  .env = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{shiny output calls, such as \code{plotOutput('id', 'Title')}}

\item{\code{.output_tabsets, .tabsets}}{together define the output layouts}

\item{\code{.env}}{debug use}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
none
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rave_updates"></a>}}
\if{latex}{\out{\hypertarget{method-rave_updates}{}}}
\subsection{Method \code{rave_updates()}}{
input initialization when \code{iEEG/ECoG} data are imported
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$rave_updates(..., .env = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{R expressions}

\item{\code{.env}}{for debug use}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rave_execute"></a>}}
\if{latex}{\out{\hypertarget{method-rave_execute}{}}}
\subsection{Method \code{rave_execute()}}{
parse, and compile to main function
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$rave_execute(..., auto = TRUE, .env = NULL, async_vars = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{R expressions}

\item{\code{auto}}{whether the module should run automatically}

\item{\code{.env}}{debug use}

\item{\code{async_vars}}{variables further passed to \code{async} module}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
none, but \code{ExecEnvir$execute} will be generated.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_browser"></a>}}
\if{latex}{\out{\hypertarget{method-set_browser}{}}}
\subsection{Method \code{set_browser()}}{
(experimental) cache R expression in browser 
\code{localStorage}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$set_browser(expr, session = getDefaultReactiveDomain())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{R expression}

\item{\code{session}}{shiny session instance}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-generate_input_ui"></a>}}
\if{latex}{\out{\hypertarget{method-generate_input_ui}{}}}
\subsection{Method \code{generate_input_ui()}}{
generate input panels according to parsed \code{rave_inputs}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$generate_input_ui(sidebar_width = 3L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{sidebar_width}}{integer from 1 to 11, the width of the input panels}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
HTML tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-generate_output_ui"></a>}}
\if{latex}{\out{\hypertarget{method-generate_output_ui}{}}}
\subsection{Method \code{generate_output_ui()}}{
generate outputs labels according to parsed 
\code{rave_outputs}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$generate_output_ui(sidebar_width = 3L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{sidebar_width}}{integer from 1 to 11, the width of the input panels,
the output panel width is calculated as \code{12-sidebar_width}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
HTML tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-is_global"></a>}}
\if{latex}{\out{\hypertarget{method-is_global}{}}}
\subsection{Method \code{is_global()}}{
(deprecated) check if variable is shared across modules.
Please use \code{cache_input} instead to get variable values.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$is_global(inputId)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{inputId}}{input ID}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExecEnvir$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
