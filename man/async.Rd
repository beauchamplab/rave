% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cls_worker.R
\name{async}
\alias{async}
\alias{use_multicores}
\alias{use_singlecore}
\alias{run_script}
\alias{async}
\title{Worker}
\usage{
use_multicores(max_worker = rave_opts$get_options("max_worker"))

use_singlecore()

run_script(expr)

async(func, .tmp_file = NULL, output_envir = new.env())
}
\arguments{
\item{max_worker}{Max number of sessions running in the background.}
}
\description{
An way to execute long code in an asynchronized settings (without-session block).
}
\details{
\code{use_multicores} is only available in Mac and Linux, which means if you are using Windows,
you have to use \code{\link{use_singlecore}}.

Run \code{print(run_script)} to see implementation. See details at \code{\link{Worker}}.
If \code{use_multicores()} is applied, the \code{expr} will be evaluated in an asynchronize
R session and will not block the main session if it takes long time to run.
}
\examples{
# Example 1: simple usage

use_multicores(20)              # Use multi-cores


worker <- run_script({
  Sys.sleep(2)                  # Wait for 3 seconds to execute next line
  print(sprintf("[\%s] The script doesn't block!", toString(Sys.time())))
})

print('Other code')

print(worker$check())           # FALSE
print(worker$result)            # Not yet evaluated


# Now wait 3 seconds
Sys.sleep(2)

print(worker$check())           # TRUE
print(worker$result)            # Evaluated Result


# Example 2: With shiny app


use_multicores(20) # Switch to use_singlecore() and try again

library(shiny)

shinyApp(
  ui = fluidPage(
    fluidRow(
      column(
        width = 12,
        verbatimTextOutput('result')
      )
    )
  ),

  server = function(input, output, session){


    timer <- reactiveTimer(20)

    result <- reactiveValues(
      text = NULL,
      text_other = NULL,
      executed = FALSE
    )


    script = function(){

      # Code Block 1
      result$text = c(result$text, sprintf("Code Block 1 - [\%s] The script that blocks", toString(Sys.time())))

      # Code Block 2
      tmp_file <- tempfile()

      worker <- run_script({
        write(sprintf('Code Block 2 Started at [\%s]', toString(Sys.time())), file = tmp_file, append = T)
        for(i in 1:10){
          Sys.sleep(1)
          write(sprintf('Current Iteration: \%d, result: \%.2f', i, rnorm(1)), file = tmp_file, append = T)
        }
        write('Done', file = tmp_file, append = T)
        Sys.sleep(1)
        sprintf("Code Block 2 - [\%s] The long script doesn't block!", toString(Sys.time()))
      })

      # Code Block 3
      result$text = c(result$text, sprintf("Code Block 3 - [\%s] The script that blocks", toString(Sys.time())))


      local({
        tmp_observer <- observe({
          timer()
          worker$check()
          if(worker$check() == TRUE){
            result$text = c(result$text, worker$result)
            unlink(tmp_file)
            tmp_observer$destroy()
          }else{
            result$text_other <- readLines(tmp_file)
          }
        })
      })
      return(result)
    }




    # Register output
    output$result <- renderPrint({

      # first time running code
      if(!isolate(result$executed)){
        result$executed = TRUE
        worker = script()
      }

      cat(result$text, sep = '\\n')
      cat('\\nBlock 2 callbacks\\n')
      cat(result$text_other, sep = '\\n')
    })
  }
)
}
