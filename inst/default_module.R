session = getDefaultReactiveDomain()
output = getDefaultReactiveOutput()
input = getDefaultReactiveInput()


# Default script for modules
`.__internal_reactives__.` = reactiveValues(
  miss_data = FALSE,
  miss_data_message = '',
  miss_data_comps = NULL,
  miss_data_size = 0,
  prevent_load = TRUE,
  incomplete_data = NULL
)

# for debug
if(is.null(session)){
  ns = I
  ..runtime_env = environment()
}

#global_reactives$execute_module
output[['.__rave_modal__.']] <- renderUI({
  # Unlock data loading
  `.__internal_reactives__.`[['prevent_load']] = FALSE

  miss_data = `.__internal_reactives__.`[['miss_data']]
  miss_data_message = `.__internal_reactives__.`[['miss_data_message']]
  total_size = `.__internal_reactives__.`[['miss_data_size']]
  if(!is.numeric(total_size) || length(total_size) != 1){
    total_size = NA
  }
  speed = rave_options('drive_speed')
  if(!is.numeric(speed) || length(speed) != 2){
    speed = 0.01
  }else{
    speed = speed[2]
  }
  # miss_data_comps = `.__internal_reactives__.`[['miss_data_comps']]
  if(!miss_data || !length(miss_data_message)){
    return(NULL)
  }

  # Check if there's any missing data
  broken_data = `.__internal_reactives__.`[['incomplete_data']]
  if(length(broken_data)){
    load_btn = NULL
    data_msg = '*There is one or more data missing. This module is diabled.'
  }else{
    load_btn = tags$button(
      id = ns('.__load_data__.'),
      type = "button",
      class = "btn btn-primary action-button shiny-bound-input",
      style = 'margin-left:15px;',
      "Load Data"
    )
    data_msg = sprintf('Estimated size: %s, (%.1f seconds)', to_ram_size(total_size), total_size * 3 * speed / 1e6)
  }

  div(
    style = "width: 100%;
    height: 100vh;
    margin-bottom: -100vh;
    background: rgba(0,0,0,0.8);
    margin-top:  -35px;
    z-index: 1000;
    position: relative;",
    div(
      class = 'centered',
      h3('Load Data...', style = 'color: cadetblue;'),
      p('This module requires the following datasets to be loaded.', style = 'font-style: italic; color: cadetblue;'),
      tags$ul(
        tagList(
          lapply(miss_data_message, tags$li)
        )
      ),
      hr(),
      div(
        style = 'float: right;',
        actionButton(ns('.__switch_back__.'), 'Go Back'),
        load_btn
        # actionButton(ns('.__load_data__.'), 'Load Data')
      ),
      p(
        data_msg
      )
    )
  )
})

observeEvent(input[['.__switch_back__.']], {
  switch_to()
})

observeEvent(input[['.__load_data__.']], {
  # Check if lock is on, prevent multiple click
  if(isolate(`.__internal_reactives__.`[['prevent_load']])){
    return()
  }
  `.__internal_reactives__.`[['prevent_load']] = TRUE

  miss_data = `.__internal_reactives__.`[['miss_data']]
  quos = `.__internal_reactives__.`[['miss_data_comps']]
  msg = `.__internal_reactives__.`[['miss_data_message']]
  if(miss_data && length(quos) && length(msg) == length(quos)){
    # load data
    n_data = length(msg)
    progress = progress('Loading data', max = n_data)
    on.exit({progress$close()})

    tryCatch({
      for(i in seq_len(n_data)){
        progress$inc(message = msg[[i]])
        eval_dirty(quos[[i]], env = ..runtime_env)
      }
      `.__internal_reactives__.`[['miss_data']] = F
    }, error = function(e){
      showNotification(p('One or more error occur during loading. The data might be broken or missing.'), type = 'error')
    })

    reload_module()
  }
})

rave_checks = function(..., data = NULL){
  data = unlist(c(data, list(...)))
  if(!length(data)){
    return()
  }
  is_reactive = F
  if(is.null(getDefaultReactiveDomain())){
    `.__internal_reactives__.` = list()
    is_reactive = T
  }


  n1 = nrow(module_tools$get_meta(name = 'trials'))
  n2 = length(preload_info$frequencies)
  n3 = length(preload_info$time_points)
  n4 = length(preload_info$electrodes)
  srate_wave = module_tools$get_sample_rate(original = F)
  srate_volt = module_tools$get_sample_rate(original = T)

  data = unlist(stringr::str_split(data, ','))
  data = stringr::str_to_lower(data)
  data = stringr::str_split(data, '\\ ')

  quos = NULL
  msg = NULL
  broken_data_type = NULL
  total_size = 0
  for(d in data){
    referenced = 'referenced' %in% d
    full = 'full' %in% d

    # 8 bytes is the default value. However, reference might not be cached, therefore in reference cases RAM size doubles. 8.25 takes into account for left-over objects
    base_size = ifelse(referenced, 16.5, 8.25)

    if('power' %in% d){
      dat = module_tools$get_power(force = F, referenced = referenced)
      if(is.null(dat)){
        quos = c(quos, rlang::quo({
          module_tools$get_power(referenced = !!referenced)
        }))
        size = n1 * n2 * n3 * n4 * base_size
        total_size = total_size + size
        size = to_ram_size(size)

        # check if directory exists
        if(!data_check$check$power_dir){
          broken_data_type = c(broken_data_type, 'power')
          msg = c(msg, 'Power (Missing)')
        }else{
          msg = c(msg, sprintf('Power (%s, %s)', ifelse(referenced, 'Referenced', 'Raw'), size))
        }
      }
      rm(dat)
    }else if('phase' %in% d){
      dat = module_tools$get_phase(force = F, referenced = referenced)
      if(is.null(dat)){
        quos = c(quos, rlang::quo({
          module_tools$get_phase(referenced = !!referenced)
        }))
        size = n1 * n2 * n3 * n4 * base_size
        total_size = total_size + size
        size = to_ram_size(size)

        # check if directory exists
        if(!data_check$check$phase_dir){
          broken_data_type = c(broken_data_type, 'phase')
          msg = c(msg, 'Phase (Missing)')
        }else{
          msg = c(msg, sprintf('Phase (%s, %s)', ifelse(referenced, 'Referenced', 'Raw'), size))
        }


      }
      rm(dat)
    }else if('volt' %in% d || 'voltage' %in% d){
      if(full){
        data_env = getDefaultDataRepository()
        dat = data_env$.private[['volt_unblocked']]
        rm(data_env)
        if(is.null(dat)){
          quos = c(quos, rlang::quo({
            module_tools$get_voltage2()
          }))
          n_tp = nrow(subject$time_points) / srate_wave * srate_volt
          n_el = nrow(subject$electrodes)

          size = n_el * n_tp * base_size
          total_size = total_size + size

          size = to_ram_size(size)

          msg = c(msg, sprintf('Voltage (No epoch, %s)', size))
        }
      }else{
        dat = module_tools$get_voltage(force = F, referenced = referenced)
        if(is.null(dat)){
          quos = c(quos, rlang::quo({
            module_tools$get_voltage(referenced = !!referenced)
          }))

          size = n1 * n3 * n4 * base_size / srate_wave * srate_volt
          total_size = total_size + size

          size = to_ram_size(size)

          # check if directory exists
          if(!data_check$check$phase_dir){
            broken_data_type = c(broken_data_type, 'voltage')
            msg = c(msg, 'Voltage (Missing)')
          }else{
            msg = c(msg, sprintf('Voltage (%s, %s)', ifelse(referenced, 'Referenced', 'Raw'), size))
          }
        }
      }
      rm(dat)
    }
  }

  broken_data_type = unique(broken_data_type)
  if(length(quos)){
    # we have data pending to be loaded
    order = order(msg)
    msg = msg[order]
    quos = quos[order]

    # show modal
    `.__internal_reactives__.`[['miss_data']] = T
    `.__internal_reactives__.`[['miss_data_message']] = msg
    `.__internal_reactives__.`[['miss_data_comps']] = quos
    `.__internal_reactives__.`[['miss_data_size']] = total_size
    `.__internal_reactives__.`[['incomplete_data']] = broken_data_type
    stop('Needs to load data')
  }else{
    `.__internal_reactives__.`[['miss_data']] = F
  }

  if(is_reactive){
    print(`.__internal_reactives__.`)
  }

  return()

}


rave_execute({})
