---
title: "An Example of RAVE Module"
author: "Zhengjia Wang"
date: "February 21, 2018"
output:
  html_document: default
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)
```

# An Example of Rave Module

This file is an example of RAVE module. It is also a standalone file that you can use to generate formal report.

To hide code blocks, you can set `knitr::opts_chunk$set(echo = FALSE)`

Let's start to draw averaged power over frequency range.

## Step 1: Initialization.

The first step is to initialize the module. During the initialization, you should load libraries by (`library(...)`), source your own functions (`source(...)`), or load data (`load(...)`). You might also want to use function `rave_prepare` to load some test data for easy-debug use.

The chunk should be given name (unnamed chunks will be ignored). During the run-time, initialization will be executed only once, and `rave_prepare` will be ignored

```{r rave_init, results = 'hide'}
library(shiny)
library(fields)
library(magrittr)
library(rave)
rave_prepare(
  subject = 'YAB_Congruency_test',
  electrodes = 14:16,
  epoch = 'YAB',
  time_range = c(1,2),
  quiet = T # quiet = FALSE will tell you which variables are attached.
)
```

## Step 3: Define inputs, and refine

Inputs are wrapped within function `rave_inputs`. They should be shiny input types such as `textInput`, `sliderInput`, etc. If you are not sure about how to write these functions, for example, `selectInput` type `?shiny::selectInput`.

**IMPORTANT**: It's highly recommended that you enter the parameter names explicitly inside of calls. For example, `func(a=b, c=d)`

Here we define two inputs: 

* `electrode`: which electrode to calculate the collapsed power
* `freq_range`: which frequency range to collapse

```{r rave_inputs}
rave_inputs(
  selectInput(inputId = 'electrode', label = 'Electrode', 
              choices = '', selected = NULL), # To make the call legit
  sliderInput(inputId = 'freq_range', label = 'Frequency Range',
              min = 0, max = 1, value = c(0,1), step = 1, post = 'Hz')
)
```

When you run the block above, you will notice that if you type `ls()`, there will be two variables with exactly the same name as your inputIds. Yes, you can use these variables as if they are local variables.

```{r, echo=TRUE, results='markup'}
ls()
```

However, this is not enough. For instance, your frequency range will vary if you choose different pre-processing parameters, or your electrode could be different according to data imported. `rave_inputs` will only run once to set up UI elements. However, such reactive information need to be reset when new data is loaded. Therefore we need one more function `rave_updates`, and this function is a little bit tricky.

We want variable `electrode` to be chosen from all available electrodes. For example, if we load electrodes $14, 15, 16$ for subject *YAB_Congruency_test*, then we might want variable `electrode` to be chosen from these three values, then we have three choices (`choices=electrodes`)

```{r rave_updates}
rave_updates(
  electrode = list(
    choices = electrodes
  ),
  freq_range = list(
    min = min(frequencies),
    max = max(frequencies),
    value = range(frequencies)
  )
)
```

Usually this is enough for `RAVE` module. However, it might not be enough for you, since you might notice that the variable `electrode` is still `NULL`. Let's make some minor changes so that we can continue the module. You can use unnamed chunks to modify the variables. These chunks will be ignored and considered as debugging code.

```{r}
electrode = 14
```

## Step 4: Define outputs

Similar to inputs, outputs are shiny output types such as `plotOutput`, `tableOutput`, or `verbatimTextOutput`, etc. Other output types are also supported (such as `plotly::plotlyOutPut`)

```{r rave_outputs}
rave_outputs(
  plotOutput(outputId = 'power_plot_func')
)
```

The `outputId`s are function names that `RAVE` will look for during the running process. Therefore we need to define those functions.

## Step 5: Execute - Core of the module

```{r rave_execute}
rave_execute({
  power$subset(
    Frequency = (Frequency >= freq_range[1] & Frequency <= freq_range[2]),
    Electrode = (Electrode == electrode)
  ) ->
    dat
})
```

## Step 6: Register output functions

In order to have these functions called by module scheduler, you MUST have there names identical to outputIds. Also, the function usually takes no arguments (some exceptions will be mentioned in the next article).

Let's write `power_plot_func`. Let's assume that we have a four-mode tensor (ECoGTensor object) `dat`: `Trial` X `Frequency` X `Time` X `Electrode` and in which there's only one electrode and frequency is already subset. Then we only need to collapse over frequencies.

```{r rave_output_func}
power_plot_func <- function(){
  # assume dat exists, check ?ECoGTensor for details
  apply(dat$data, 3, rowMeans) %>% 
    t %>% 
    image.plot
}
```


## Step 7: Test if your module is running properly

```{r}
power_plot_func()
```



